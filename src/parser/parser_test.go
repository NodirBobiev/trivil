package parser

import (
	"fmt"
	"testing"
	"trivil/env"
)

var valid_texts = []string{
	"модуль м;",
	"модуль м",
	"модуль м\n",
	"модуль м; осторожно; вход{ 1(:осторожно Слово64) }",
	"модуль x; фн print_int(a: Цел) @внеш; вход { print_int(5) }",
	"модуль м; импорт \"путь\"",
	"модуль м; пусть а: Цел := 0",
	"модуль м; пусть а*: Цел := 0",
	"модуль м; пусть а: Цел = 0",
	"модуль м; пусть а*: Цел = 0",
	"модуль м; конст а: Цел = 1",
	"модуль м; конст а*: Цел = 1",
	"модуль м; конст а = 1",
	"модуль м; конст а* = 1",
	"модуль м; конст *( а: Цел = 1; б )",
	"модуль м; конст ( а: Цел = 1; б )",
	"модуль м; конст ( а = 1; б )",
	"модуль м; конст ( а: Цел = 1; б; в: Цел = 7; г )",
	"модуль м; конст ( а = 1; б; в: Цел = 7; г )",
	"модуль м; конст ( а = 1; б; в = 7; г )",
	"модуль м; тип а = []Цел",
	"модуль м; тип а* = []Цел",
	"модуль м; тип а = класс {}",
	"модуль м; тип а = класс (Цел) {}",
	"модуль м; тип а = класс { а: Цел=1 }",
	"модуль м; тип а = класс { а: Цел=1; b: Строка=1 }",
	"модуль м; тип а* = класс { а: Цел=1; b*: Строка=1 }",

	"модуль м; фн Ф() {}",
	"модуль м; фн Ф(): Цел {}",
	"модуль м; фн Ф(а: Т) {}",
	"модуль м; фн Ф(а: Т, б: Цел) {}",
	"модуль м; фн Ф(а: Т, б: Цел): Строка {}",
	"модуль м; тип К = класс {}; фн (к: К) метод() {}",

	"модуль м; тип К = класс {}; вход{ пусть к: мб К = 1}",

	"модуль м; вход { a.b }",
	"модуль м; вход { a(:Цел) }",
	"модуль м; вход { a[] }",
	"модуль м; вход { a[1] }",
	"модуль м; вход { a[1, 2] }",
	"модуль м; вход { a[1, 2,] }",
	"модуль м; вход { a[1:2, 2:3] }",

	"модуль м; вход { a{} }",
	"модуль м; вход { a{б: 1} }",
	"модуль м; вход { a{б: 1,} }",
	"модуль м; вход { a{б: 1, в: 'ф', г: \"фф\" } }",

	"модуль м; фн Ф() @внеш; вход {}",
	"модуль м; фн Ф() @внеш(); вход {}",
	"модуль м; фн Ф() @внеш(\"имя\":\"что-то\"); вход {}",

	"модуль м; вход { выбор 1 {} }",
	"модуль м; вход { выбор 1 { когда 1: } }",
	"модуль м; вход { выбор 1 { когда 1: а := 1} }",
	"модуль м; вход { выбор 1 { когда 1: когда 2,3: } }",
	"модуль м; вход { выбор 1 { когда 1: когда 2,3: а := 2} }",
	"модуль м; вход { выбор 1 { когда 1: когда 2,3: другое} }",
	"модуль м; вход { выбор 1 {другое} }",
	"модуль м; вход { выбор 1 {другое а := 5} }",

	"модуль м; вход { выбор тип 1 { когда Цел64: когда Лог: другое} }",
	"модуль м; вход { выбор пусть т: тип 1 { когда Цел64: когда Лог: другое} }",

	"модуль м; вход { пусть с?: мб Строка = \"\"; пусть с = с^ }",
}

var invalid_texts = []string{
	"иначе м",
	"модуль м; импорт;",
	"модуль м; импорт 12",
	"модуль м; пусть 'a': Цел",
	"модуль м; пусть 12: Цел",
	"модуль м; пусть a, б: Цел",
	"модуль м; пусть a+ Цел",
	"модуль м; пусть a: 12",
	"модуль м; конст а: Цел",
	"модуль м; конст { а: Цел = 1 )",
	//	"модуль м",

	"модуль м; вход { a.1] }",
	"модуль м; вход { a(:) }",
	"модуль м; вход { a[1, 2:3] }",

	"модуль м; фн Ф() @нечто; вход {}",
	"модуль м; фн Ф() @внеш('эму':'что-то'); вход {}",

	"модуль м; фн Ф(а: ...Цел64, б: Цел64) {}",
	"модуль м; вход {  1(:осторожно Цел64) }",
}

//===

func TestValid(t *testing.T) {
	fmt.Printf("--- valid tests: %d ---\n", len(valid_texts))
	t.Run("valid tests", func(t *testing.T) {
		for _, text := range valid_texts {
			checkValid(t, text)
		}
	})
}

func TestInvalid(t *testing.T) {
	fmt.Printf("--- tests for errors: %d ---\n", len(invalid_texts))
	t.Run("invalid tests", func(t *testing.T) {
		for _, text := range invalid_texts {
			checkInvalid(t, text)
		}
	})
}

func checkValid(t *testing.T, text string) {
	parseSrc(text)
	if env.ErrorCount() > 0 {
		t.Errorf("Unexpected %d errors in text:\n%s\n", env.ErrorCount(), text)
		env.ClearErrors()
	}
}

func checkInvalid(t *testing.T, text string) {
	parseSrc(text)
	if env.ErrorCount() > 0 {
		env.ClearErrors()
	} else {
		t.Errorf("Error(s) expected in text:\n%s\n", text)
	}
}

func parseSrc(text string) {
	var src = env.AddImmSource(text)

	Parse(src)
}
