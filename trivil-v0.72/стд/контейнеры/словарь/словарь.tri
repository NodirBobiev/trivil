//=== Настройка:
//  тип Ключ = <тип>
//  тип Значение = <тип>
//  конст хеш = ... или фн (к: Ключ): Слово64 {}
//  конст размер = 1021 - простое число
//101	 199	307	401	503	509	601	701	809	907	1009	

модуль словарь
осторожно // только для ускорения

импорт "стд::строки"

тип Элемент* = класс {
    ключ*: Ключ = позже
    значение*: Значение  := позже
}

тип Элементы? = []мб Элемент

тип Словарь* = класс {
    элементы = Элементы?[длина: размер, *: пусто] 
    кол-во: Цел64 := 0
}

фн (с: Словарь) число элементов*(): Цел64 {
    вернуть с.кол-во
}

фн (с: Словарь) добавить*(к: Ключ, з: Значение) {

    надо с.кол-во < длина(с.элементы) * 2 / 3 
    иначе авария(строки.ф("слишком много элементов в таблице: $; из $;", с.кол-во, длина(с.элементы)))

    пусть № := хеш(к) % длина(с.элементы)(:осторожно Слово64)
    пока с.элементы[№] # пусто {
        пусть э = с.элементы[№]^
        если э.ключ = к {
            э.значение := з
            вернуть
        }

        № := (№ + 0x1) % длина(с.элементы)(:осторожно Слово64)
    }

    с.элементы[№] := Элемент{ключ: к, значение: з}
    с.кол-во++
}

фн (с: Словарь) найти*(к: Ключ): мб Элемент {

    пусть № := хеш(к) % длина(с.элементы)(:осторожно Слово64)
    пока с.элементы[№] # пусто {
        пусть э = с.элементы[№]^
        если э.ключ = к {
            вернуть э
        }

        № := (№ + 0x1) % длина(с.элементы)(:осторожно Слово64)
    }
    вернуть пусто
}

//==== итератор

/* Использование:
    пусть и = словарь.начать()
    пока и.элемент? # пусто {
        вывод.ф(" $;=$;", и.элемент?^.ключ, и.элемент?^.значение)
        и.следующий()
    }
*/

тип Итератор = класс {
    элемент?*: мб Элемент := пусто
    словарь: Словарь = позже
    № := 0
}

фн (с: Словарь) начать*(): Итератор {
    пусть и = Итератор{словарь: с}
    и.следующий()
    вернуть и
}

фн (и: Итератор) следующий*() {
    и.элемент? := пусто
    пусть с = и.словарь

    пока и.№ < длина(с.элементы) {
        если с.элементы[и.№] # пусто {
            и.элемент? := с.элементы[и.№]
            и.№++
            вернуть
        }
        и.№++
    }
}

