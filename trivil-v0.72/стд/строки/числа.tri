модуль строки

//импорт "стд::юникод"

конст макс-Цел64 = 0x7FFFFFFFFFFFFFFF(:Цел64)
конст макс-Слово64 = 0xFFFFFFFFFFFFFFFF

// Извлекает целое число из строки, возвращает истину, если удалось
// формат: ('+' | '-')? цифра10+
фн строка в цел*(с: Строка, рез := Цел64): Лог {
    рез := 0
    
    пусть с8 = с(:Строка8)
    надо длина(с8) > 0 иначе вернуть ложь

    пусть № := 0
    пусть нег = с8[0] =  '-'(:Байт)
    если нег | с8[0] =  '+'(:Байт) {
        №++
        надо № < длина(с8) иначе вернуть ложь
    }
    
    пусть сим := с8[№](:Символ)
    надо цифра?(сим) иначе вернуть ложь

    пусть число := 0
    пока истина {
        пусть цифра = сим(:Цел64) - '0'(:Цел64)
        
        // проверка выхода за границу
        надо число <= (макс-Цел64 - цифра) / 10 иначе вернуть ложь
        
        число := число*10 + цифра
        №++
        если № >= длина(с8) { 
            если нег {
                число := - число
            }
            рез := число
            вернуть истина
        }
        сим := с8[№](:Символ)

        надо цифра?(сим) иначе прервать
    }
    вернуть ложь
}

// Извлекает беззнаковое целое число из строки, возвращает истину, если удалось
// формат: 0x цифра16+ | цифра10+
фн строка в слово*(с: Строка, рез := Слово64): Лог {
    рез := 0

    пусть с8 = с(:Строка8)
    надо длина(с8) > 0 иначе вернуть ложь

    если с8[0]  = '0'(:Байт) {
        надо длина(с8) > 1 иначе вернуть истина // рез = 0

        пусть след = с8[1] 
        если след = 'x'(:Байт) | след = 'X'(:Байт) {
            надо длина(с8) > 2 иначе вернуть ложь 

            вернуть слово16(с8, 2, рез)
        }
    }

    вернуть слово10(с8, 0, рез)
}

// Извлекает 16-ричное число
// № - корректный индекс
фн слово16(с8: Строка8, №: Цел64, рез := Слово64): Лог {

    пусть сим := с8[№](:Символ)
    
    пусть цифра := цифра16(сим)
    надо цифра < 0x10 иначе вернуть ложь

    пусть число: Слово64 := 0
    пока истина {
        
        // проверка выхода за границу
        надо число <= (макс-Слово64 - цифра) / 0x10 иначе вернуть ложь
        
        число := число * 0x10 + цифра
        №++
        если № >= длина(с8) { 
            рез := число
            вернуть истина
        }
        сим := с8[№](:Символ)

        цифра := цифра16(сим)
        надо цифра < 0x10 иначе вернуть ложь
    }
    
    вернуть ложь // TODO: сделать другой цикл выше
}

// Извлекает 10-ричное слово
фн слово10(с8: Строка8, №: Цел64, рез := Слово64): Лог {

    пусть сим := с8[№](:Символ)
    надо цифра?(сим) иначе вернуть ложь

    пусть число := 0x0
    пока истина {
        пусть цифра = сим(:Слово64) - '0'(:Слово64)
        
        // проверка выхода за границу
        надо число <= (макс-Слово64 - цифра) / 0xA иначе вернуть ложь
        
        число := число * 0xA + цифра
        №++
        если № >= длина(с8) { 
            рез := число
            вернуть истина
        }
        сим := с8[№](:Символ)

        надо цифра?(сим) иначе прервать
    }
    вернуть ложь
}

фн цифра?(сим: Символ): Лог {
    вернуть сим >= '0' & сим <= '9'
}

// Возвращает 16, если это не цифра
фн цифра16(сим: Символ): Слово64 {
    выбор {
    когда сим >= '0' & сим <= '9': 
        вернуть сим(:Слово64) - '0'(:Слово64)
    когда сим >= 'A' & сим <= 'F':
        вернуть 0xA + сим(:Слово64) - 'A'(:Слово64)
    когда сим >= 'a' & сим <= 'f':
        вернуть 0xA + сим(:Слово64) - 'a'(:Слово64)
    другое 
        вернуть 16
    }
}

//==== вещественные

// Извлекает вещественное число из строки, возвращает истину, если удалось
фн строка в вещ*(с: Строка, рез := Вещ64): Лог {
    вернуть sysapi_string_to_float64(с, рез)
}    
