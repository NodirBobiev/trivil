модуль строки

импорт "стд::юникод"

тип Строки = []Строка

// Построить строку по формату
фн ф*(формат: Строка, аргументы: ...*): Строка {
    пусть сб = Сборщик{}
    сб.ф(формат, аргументы...)
    вернуть сб.строка()
}

//==== сборка

фн соединить*(разделитель: Строка, строки: ...Строка): Строка {

    надо длина(строки) > 0 иначе вернуть ""

    пусть размер := 0
    пусть № := 0
    пока № < длина(строки) {
        размер := размер + длина(строки[№](:Строка8))
        №++
    }
    размер := размер + (длина(строки) -1)* длина(разделитель(:Строка8))

    пусть сб = Сборщик{байты: Байты[выделить: размер]}
    № := 0
    пока № < длина(строки) - 1 {
        сб.добавить строку(строки[№])
        сб.добавить строку(разделитель)
        №++
    }
    сб.добавить строку(строки[№])

    вернуть сб.строка()
}

фн собрать*(строки: ...Строка): Строка {

    надо длина(строки) > 0 иначе вернуть ""

    пусть размер := 0
    пусть № := 0
    пока № < длина(строки) {
        размер := размер + длина(строки[№](:Строка8))
        №++
    }

    пусть сб = Сборщик{байты: Байты[выделить: размер]}
    № := 0
    пока № < длина(строки) {
        сб.добавить строку(строки[№])
        №++
    }

    вернуть сб.строка()
}

//==== разборка

фн извлечь*(с: Строка, №-байта: Цел64, число-байтов: Цел64): Строка {
    вернуть tri_substring(с(:Строка8), №-байта, число-байтов)
}

фн извлечь из байтов*(байты: Байты, №-байта: Цел64, число-байтов: Цел64): Строка {
    вернуть tri_substring_from_bytes(байты, №-байта, число-байтов)
}

// Разбирает строку 'с' на все подстроки, разделенные строкой 'разделитель' и возвращает вектор подстрок.
// Если строка не содержит разделитель или разделитель пустой,  возвращает вектор длины 1, единственным элементом которого является строка 'с'.
фн разобрать*(с: Строка, разделитель: Строка): Строки {

    пусть р8 = разделитель(:Строка8)

    выбор длина(р8) {
    когда 0: вернуть Строки[с]
    когда 1: 
        вернуть разобрать1(с, р8[0])
    другое
        авария("не реализовано - длина разделителя > 1")
    }
    вернуть Строки[]
}

фн разобрать1(с: Строка, разделитель: Байт): Строки {

    пусть рез = Строки[]
    пусть с8 = с(:Строка8)
    пусть № := 0
    пусть №-разд := -1
    пока № < длина(с8) {
        если с8[№] = разделитель  {
            если №-разд + 1 = № {
                рез.добавить("")
            } иначе {
                рез.добавить(tri_substring(с8, №-разд+1, № - №-разд - 1))
            }
            №-разд := №
        }
        №++
    }
    рез.добавить(tri_substring(с8, №-разд+1, длина(с8) - №-разд - 1))
    
    вернуть рез
}

// Делить строку на две подстроки по первому вхождению разделителя. Если разделитель есть, возвращает истину.
// Если строка не содержит разделитель или разделитель пустой,  первая = исходной строке, вторая - "".
фн разделить*(с: Строка, разделитель: Строка, первая := Строка, вторая := Строка): Лог {

    пусть и = индекс(с, 0, разделитель)
    надо и >= 0 иначе {
        первая := с
        вторая := ""
        вернуть ложь
    }

    пусть с8 = с(:Строка8)
    пусть р8 = разделитель(:Строка8)

    первая := tri_substring(с8, 0, и)
    вторая := tri_substring(с8, и + длина(р8), длина(с8) - (и +длина(р8)))

    вернуть истина
}

//==== анализ строки

// Возвращает истину, если строка начинается с префикса
фн есть префикс*(с: Строка, префикс: Строка): Лог {
    пусть с8 = с(:Строка8)
    пусть п8 = префикс(:Строка8)

    надо длина(п8) <= длина(с8) иначе вернуть ложь
    
    пусть № := 0
    пока № < длина(п8) {
        если с8[№] # п8[№] { вернуть ложь }
        №++
    }
    вернуть истина
}

// Возвращает истину, если строка заканчивается суффиксом
фн есть суффикс*(с: Строка, суффикс: Строка): Лог {
    пусть с8 = с(:Строка8)
    пусть к8 = суффикс(:Строка8)

    надо длина(к8) <= длина(с8) иначе вернуть ложь
    
    пусть №1 := длина(к8) - 1
    пусть №2 := длина(с8) - 1
    пока №1 >= 0 {
        если с8[№2] # к8[№1] { вернуть ложь }
        №1--
        №2--
    }
    вернуть истина
}

//==== обрезка

// Возвращает строку с обрезанными начальными и конечными пробельными символами
// Внимание: наивная реализация, предполагающая, что все пробельные символы из ascii7
фн обрезать пробельные символы*(с: Строка): Строка {

    пусть с8 = с(:Строка8)
    пусть №1 := 0
    пока №1 < длина(с8) {
        надо с8[№1] < 0x80(:Байт) иначе прервать
        надо юникод.пробельный символ?(с8[№1](:Символ)) иначе прервать
        №1++
    }

    пусть №2 := длина(с8) 
    пока №2 > №1 {
        пусть байт = с8[№2-1]
        надо  байт < 0x80(:Байт) иначе прервать
        надо юникод.пробельный символ?(байт(:Символ)) иначе прервать
        №2--
    }
    
    вернуть tri_substring(с8, №1, №2 - №1)
}
