/* тесты 
    пусть ю = Байты[0xd1, 0x84]     0x444
    пусть ю = Байты[0xe0, 0xa6, 0x80]   0x980   
    пусть ю = Байты[0xf0, 0x90, 0x8a, 0x80]       0x10280
*/

модуль utf8

конст Недоп-символ* = '\uFFFD'

тип Байты = []Байт

// Возвращает следующий символ, начиная с байтовой позиции №, и изменяя её
// Записывает длину символа в "число-байтов"
фн декодировать символ*(байты: Байты, № := Цел64, число-байтов := Цел64): Символ {

    число-байтов := 0

    надо № < длина(байты) иначе вернуть Недоп-символ
    пусть тек = байты[№](:Слово64)
    №++
        
    число-байтов := 1
    если тек < 0x80 {
        вернуть тек(:Символ)
    }
    
    // Первый байт должен быть в диапазоне [0xc2..0xf4]
    надо тек >=  0xc2 & тек <= 0xf4 иначе вернуть Недоп-символ
    
    если тек < 0xe0 { // 2-х байтовая последовательность
        число-байтов := 2
        надо № < длина(байты) иначе вернуть Недоп-символ

        пусть тек1 = байты[№](:Слово64)
        №++       
        надо тек1 :& 0xc0 = 0x80 иначе вернуть Недоп-символ
        
        вернуть ((тек :& 0x1f) << 6 :| тек1 :& 0x3f)(:Символ)
    }
    
    если тек < 0xf0 { // 3-х байтовая последовательность
        число-байтов := 3
        надо № + 1 < длина(байты) иначе вернуть Недоп-символ
        пусть тек1 = байты[№](:Слово64)
        пусть тек2 = байты[№+1](:Слово64)
        № := № +2  

        надо тек1 :& 0xc0 = 0x80 иначе вернуть Недоп-символ
        надо тек2 :& 0xc0 = 0x80 иначе вернуть Недоп-символ    

        // Проверка суррогатов
        если тек = 0xed & тек1 > 0x9f { вернуть Недоп-символ  }     

        пусть код =  (тек :& 0xf) << 12 :| (тек1 :& 0x3f) << 6 :| тек2 :& 0x3f
        надо код >= 0x800 иначе вернуть Недоп-символ 
        
        вернуть код(:Символ)       
    }    
        
    // 4-х байтовая последовательность      
    число-байтов := 4
    надо № + 2 < длина(байты) иначе вернуть Недоп-символ
    пусть тек1 = байты[№](:Слово64)
    пусть тек2 = байты[№+1](:Слово64)
    пусть тек3 = байты[№+2](:Слово64)
    № := № +3  

    надо тек1 :& 0xc0 = 0x80 иначе вернуть Недоп-символ
    надо тек2 :& 0xc0 = 0x80 иначе вернуть Недоп-символ    
    надо тек3 :& 0xc0 = 0x80 иначе вернуть Недоп-символ

    // проверка диапазона: (0x10000 .. 0x10ffff
    если тек = 0xf0 {
        надо тек1 >= 0x90 иначе вернуть Недоп-символ
    } иначе если тек = 0xf4 {
         надо тек1 <= 0x8f иначе вернуть Недоп-символ   
    }
    
    пусть код =  (тек :& 0x7) << 18 :| (тек1 :& 0x3f) << 12  :| (тек2 :& 0x3f) << 6 :| тек3 :& 0x3f    
        
    вернуть код(:Символ)    
}

// Пропуская один символ, считая его длину. 
// Не проверяет символы на некорректность
фн пропустить символ*(байты: Байты, № := Цел64, число-байтов := Цел64) {

    число-байтов := 0
    надо № < длина(байты) иначе вернуть
    
    пусть тек = байты[№](:Слово64)
    №++

    число-байтов := 1
    если тек < 0x80 {
        вернуть 
    }
    
    // Первый байт должен быть в диапазоне [0xc2..0xf4]
    надо тек >=  0xc2 & тек <= 0xf4 иначе вернуть
    
    если тек < 0xe0 { // 2-х байтовая последовательность
        число-байтов := 2
        надо № < длина(байты) иначе вернуть 
        №++       
        вернуть 
    }
    
    если тек < 0xf0 { // 3-х байтовая последовательность
        число-байтов := 3
        надо № + 1 < длина(байты) иначе вернуть
        № := № +2  
        вернуть 
    }    
        
    // 4-х байтовая последовательность      
    число-байтов := 4
    надо № + 2 < длина(байты) иначе вернуть
    № := № +3  
}
