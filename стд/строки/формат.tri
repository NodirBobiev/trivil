модуль строки
осторожно

импорт "стд::юникод"
импорт "стд::юникод/utf8"

/*
формат-аргумента: ‘$’ основа? ( ‘:’ размещение)?   ‘;’
вид
    : тип
    | стр #? ограничение? // # - "в кавычках" escaped
    | сим #?    // # 'в кавычках' escaped
    | адр 0? размер?
    | цел +? 0? размер?
    | (ш | Ш) #? 0? размер?  // # - 0x
    | вещ +? 0? размер? (‘.’ точность)? (e | E)?

Флаги:
    # - модификация формата
    + - обязательный знак числа
    0 - выравнивание нулями слева

ограничение: число | *
размер: число | *
точность: число | *

размещение: (заполнитель?выравнивание)? ширина?
выравнивание:= '<' | '^' | '>'
ширина: число | '*'
*/

// TODO: размещение и форматы вещественного

тип Символы = []Символ 

//!!!!! временно для отладки
фн __с(с: Строка) {
    строка("!")
    строка(с)
    кс()
}
фн __ц(с: Строка, ц: Цел64) {
    строка("!")
    строка(с)
    строка("=")
    цел64(ц)
    кс()
}
//====

конст (
    _неоп = 0
    _умолчание
    _тип
    _стр 
    _сим
    _адр
    _цел
    _шест
    _вещ
)

конст (
    КОН-СТР = 0(:Символ)
    ПРОБЕЛ = ' '(:Байт)
)

тип Разборщик = класс {
    сб: Сборщик = позже

    формат: Символы = позже 
    сим := КОН-СТР // текущий символ формата
    №-сим := 0 // номер следующего символа

    №-арг := 0 // номер аргумента
    
    // обработка ошибок
    ошибка := ложь
    сообщение := ""

    // формат аргумента:
    вид-формата := _неоп
    имя-формата := "" // для ошибок
    число-доп-аргументов := 0 
    размер := -1  // не задан
    точность := -1 // для вещественного
    
    знак := ложь // для знаковых чисел: цел, вещ
    нули := ложь // заполнение нулями: адр, цел, ш, Ш, вещ
    альт := ложь // 
    заглавные := ложь // шестнадцатеричные и вещественные
    
    вещ-экспонента := ложь
}

фн (сб: Сборщик) ф*(фс: Строка, список: ...*) {

    пусть р = Разборщик{сб: сб, формат: фс(:Символы) }  
    р.взять символ()
    
    пока р.следующий формат() {
        надо р.№-арг + р.число-доп-аргументов < длина(список) иначе {
            р.ошибка := истина
            р.сообщение := "не достаточно аргументов"
            прервать
        }

        если р.число-доп-аргументов > 0 {
            р.размер := р.разобрать числовой аргумент(тег(список[р.№-арг + 1]), нечто(список[р.№-арг + 1]))
            надо ~ р.ошибка иначе прервать
        }

        р.добавить аргумент(тег(список[р.№-арг]), нечто(список[р.№-арг]))
        р.№-арг := р.№-арг + 1 + р.число-доп-аргументов
    }
    если ~ р.ошибка & р.№-арг < длина(список) {
        р.ошибка := истина
        р.сообщение := "слишком много аргументов"
    }
    
    если р.ошибка {
        р.сб.добавить строку("!формат:")
        р.сб.добавить строку(р.сообщение)
        р.сб.добавить символ('!')
    }    
}

//=== разбор форматной строки

фн (р: Разборщик) взять символ() {
    надо р.№-сим < длина(р.формат) иначе {
        р.сим := КОН-СТР
        вернуть
    }
    р.сим := р.формат[р.№-сим]
    р.№-сим++
}

фн (р: Разборщик) следующий формат(): Лог {
    пока ~ р.ошибка & р.сим # КОН-СТР {
    
        надо р.сим # 0(:Символ) иначе авария("0x0 в форматной строке") 
        //строка("'"); символ(р.формат[р.№-сим]); кс()
    
        если р.сим = '$' {
            если р.разобрать формат() { вернуть истина }
        } 
        р.сб.добавить символ(р.сим)
        р.взять символ()
    }
    вернуть ложь
}

фн (р: Разборщик) разобрать формат(): Лог {

   // почистить состояние
    р.число-доп-аргументов := 0 
    р.размер := -1  
    р.точность := -1 // для вещественного
    
    р.знак := ложь 
    р.нули := ложь
    р.альт := ложь 
    р.заглавные := ложь 
    
    р.вещ-экспонента := ложь

    р.взять символ()
    если р.сим = '$' {  вернуть ложь  }
    
    //р.ошибка := ложь
    р.разобрать основу()
    надо ~ р.ошибка иначе вернуть ложь
    
    если р.сим = ';' {
        р.взять символ()
        вернуть истина
    }     

    если р.сим = ':' {
        р.взять символ()
        р.разобрать размещение()
    }     

    вернуть ~ р.ошибка
}

фн (р: Разборщик) разобрать основу() {

    надо р.сим # КОН-СТР иначе {
        р.сообщение := "формат оборван"
        р.ошибка := истина
        вернуть 
    }

    пусть символы = Символы[]
    пусть № := 0
    пока юникод.буква?(р.сим) {
        символы.добавить(р.сим)
        №++
        р.взять символ()
    }
    пусть имя = символы(:Строка)
    р.имя-формата := имя
    
//    __ц("длина", длина(символы))
//    __с(имя)

    выбор имя {
    когда "": 
        р.вид-формата := _умолчание
        р.имя-формата := "$;"
    когда "тип": р.вид-формата := _тип
    когда "стр": р.извлечь стр()
    когда "сим": р.извлечь сим()
    когда "адр": р.извлечь адр()
    когда "цел": р.извлечь цел()
    когда "вещ": р.извлечь вещ()
    когда "ш": р.извлечь шест(ложь)
    когда "Ш": р.извлечь шест(истина)
    другое
        р.сообщение := "неизвестный формат"
        р.ошибка := ложь
    }
}

//=== элементы формата

фн (р: Разборщик) признак(сим: Символ): Лог {
    если р.сим = сим {
        р.взять символ()
        вернуть истина
    }
    вернуть ложь
}

фн (р: Разборщик) число или аргумент(): Цел64 {
    если р.сим = '*' {
        р.взять символ()
        р.число-доп-аргументов++
        вернуть 0
    }
    если ~ юникод.цифра?(р.сим) { вернуть -1 }
    
    пусть № := 0
    // TODO: заменить на библиотечный strconv
    пока истина {
        пусть цифра = р.сим(:Цел64) - '0'(:Цел64)
        № := №*10 + цифра
        р.взять символ()            
        надо юникод.цифра?(р.сим) иначе прервать
    }
    вернуть №
}

//==== варианты основы

фн  (р: Разборщик) извлечь стр() {
    р.вид-формата := _стр
    р.альт := р.признак('#')
    р.размер := р.число или аргумент()    
}

// сим #?
фн  (р: Разборщик) извлечь сим() {
    р.вид-формата := _сим
    р.альт := р.признак('#')    
    // TODO: сделать #
}

// адр 0? размер?
фн  (р: Разборщик) извлечь адр() {
    р.вид-формата := _адр
    р.альт := истина
    р.нули := р.признак('0')
    р.размер := р.число или аргумент()    
}

// цел +? 0? размер?
фн  (р: Разборщик) извлечь цел() {
    р.вид-формата := _цел
    р.знак := р.признак('+')
    р.нули := р.признак('0')
    р.размер := р.число или аргумент()
//    __ц("число", р.размер)
}

// (ш | Ш) #? 0? размер?  // # - 0x
фн  (р: Разборщик) извлечь шест(заглавные: Лог) {
    р.вид-формата := _шест
    р.альт := р.признак('#')
    р.нули := р.признак('0')
    р.заглавные := заглавные
    р.размер := р.число или аргумент()    
}

// вещ +? 0? размер? (‘.’ точность)? (e | E)?
фн  (р: Разборщик) извлечь вещ() {
    р.вид-формата := _вещ
    р.знак := р.признак('+')
    р.нули := р.признак('0')
    р.размер := р.число или аргумент()
    если р.сим = '.' {
        р.взять символ()
        р.число или аргумент()
    }
    если р.сим = 'e' {
        р.вещ-экспонента := истина
        р.взять символ()
    } иначе если р.сим = 'E' {
        р.вещ-экспонента := истина
        р.заглавные := истина
        р.взять символ()
    }
}

фн (р: Разборщик) разобрать размещение() {
    // взять ;
     авария("не сделано")
}

//=== добавление аргументов

фн (р: Разборщик) разобрать числовой аргумент(аргТ: Слово64, арг: Слово64): Цел64 {
    выбор аргТ {
    когда тег(Цел64): 
        вернуть арг(:осторожно Цел64)
    когда тег(Слово64), тег(Байт): 
        вернуть арг(:Цел64)
    другое
        р.ошибка := истина
        р.сообщение := "дополнительный аргумент для '*' не является числом"
        вернуть 0
    }
}

фн (р: Разборщик) добавить аргумент(аргТ: Слово64, арг: Слово64) {

    выбор р.вид-формата {
    когда _умолчание: р.добавить по умолчанию(аргТ, арг)
    когда _тип: р.добавить-тип(аргТ, арг)
    когда _стр: р.добавить стр(аргТ, арг)
    когда _сим: р.добавить сим(аргТ, арг)
    когда _адр: р.добавить адр(аргТ, арг)
    когда _цел: р.добавить цел(аргТ, арг)
    когда _шест: р.добавить шест(аргТ, арг)
    когда _вещ: р.добавить вещ(аргТ, арг)
    другое
        авария(соединить("", "формат не сделан: ", р.имя-формата))
    }
}

//=== добавление по формату

// Формат по умолчанию
фн (р: Разборщик) добавить по умолчанию(аргТ: Слово64, арг: Слово64) {

    выбор аргТ {
    когда тег(Цел64): 
        р.добавить целое10(арг(:осторожно Цел64))
    когда тег(Слово64): 
        р.добавить число10(арг, ложь)
    когда тег(Символ), тег(Байт):
        //р.добавить строку("0x"); 
        р.альт := истина
        р.добавить число16(арг)
    когда тег(Вещ64): 
        р.добавить вещественное(арг(:осторожно Вещ64))        
    когда тег(Лог): 
        если арг = 0x0 { р.добавить строку("ложь") }
        иначе { р.добавить строку("истина") }
    когда тег(Строка): 
        р.добавить строку(арг(:осторожно Строка))
    когда тег(Пусто): 
        р.добавить строку("пусто")
    другое
        р.сб.добавить строку(" *формат по умолчанию ($;) не сделано: тег 0x"); р.добавить число16(аргТ)
    }
}

// Формат "тип"
фн (р: Разборщик) добавить-тип(аргТ: Слово64, арг: Слово64) {
    // если это класс
    если tri_isClassTag(аргТ) {
        р.добавить строку("класс ")
        р.добавить строку(tri_className(аргТ))
        вернуть
    }
    пусть имя = встроенный-тип(аргТ)
    если имя # "" {
        р.добавить строку(имя)
        вернуть
    }

    р.ошибка := истина
    р.сообщение := соединить("", "'тип' не реализован", р.имя-формата)
}

фн встроенный-тип(аргТ: Слово64): Строка {
    выбор {
    когда аргТ = тег(Байт): вернуть "Байт"
    когда аргТ = тег(Цел64): вернуть "Цел64"
    когда аргТ = тег(Слово64): вернуть "Слово64"
    когда аргТ = тег(Вещ64): вернуть "Вещ64"
    когда аргТ = тег(Лог): вернуть "Лог"
    когда аргТ = тег(Символ): вернуть "Символ"
    когда аргТ = тег(Строка): вернуть "Строка"
    //когда аргТ = тег(Строка8): вернуть "Строка8"
    когда аргТ = тег(Пусто): вернуть "Пусто"
    }
    вернуть ""
}


// Формат "стр"
фн (р: Разборщик) добавить стр(аргТ: Слово64, арг: Слово64) {

    выбор аргТ {
    когда тег(Строка): 
        р.добавить строку(арг(:осторожно Строка))
    другое
        р.ошибка := истина
        р.сообщение := соединить("", "неверный тип для формата ", р.имя-формата)
    }
}

// Формат "сим"
фн (р: Разборщик) добавить сим(аргТ: Слово64, арг: Слово64) {

    выбор аргТ {
    когда тег(Символ): 
        р.добавить символ(арг(:Символ))
    другое
        р.ошибка := истина
        р.сообщение := соединить("", "неверный тип для формата ", р.имя-формата)
    }
}

// Формат "адр"
фн (р: Разборщик) добавить адр(аргТ: Слово64, арг: Слово64) {

    выбор {
    когда аргТ = тег(Строка): 
        р.добавить число16(арг)
    когда tri_isClassTag(аргТ):
        р.добавить число16(арг)
    другое
        р.ошибка := истина
        р.сообщение := "неверный тип для формата адр"
        // TODO: добавить название типа - рефлексия?
    }
}

// Формат "цел"
фн (р: Разборщик) добавить цел(аргТ: Слово64, арг: Слово64) {

    выбор аргТ {
    когда тег(Цел64): 
        р.добавить целое10(арг(:осторожно Цел64))
    когда тег(Слово64): 
        р.добавить число10(арг, ложь)
    когда тег(Символ), тег(Байт):
        р.добавить число10(арг, ложь)
    другое
        р.ошибка := истина
        р.сообщение := соединить("", "неверный тип для формата ", р.имя-формата)
        // TODO: добавить название типа - рефлексия?
    }
}

// Формат "шест"
фн (р: Разборщик) добавить шест(аргТ: Слово64, арг: Слово64) {

    выбор аргТ {
    когда тег(Цел64), тег(Слово64), тег(Символ), тег(Байт), тег(Строка):
        р.добавить число16(арг)
    другое
        р.ошибка := истина
        р.сообщение := соединить("", "неверный тип для формата ", р.имя-формата)
        // TODO: добавить название типа - рефлексия?
    }
}

// Формат "вещ"
фн (р: Разборщик) добавить вещ(аргТ: Слово64, арг: Слово64) {

    выбор аргТ {
    когда тег(Вещ64):
        р.добавить вещественное(арг(:осторожно Вещ64))
    другое
        р.ошибка := истина
        р.сообщение := ф("$; $;: $ш;", "неверный тип для формата ", р.имя-формата, аргТ)
//        р.сообщение := соединить("", "неверный тип для формата ", р.имя-формата)
        // TODO: добавить название типа - рефлексия?
    }
}

//=== добавление по данным

// ограничение < 0 - строка целиком
// ограничение >= 0 - число обрабатываемых символов
фн (р: Разборщик) добавить строку(ст: Строка) {
    надо ~ р.альт иначе авария("не реализовано - # для строки ")

    пусть ограничение := р.размер
//__ц("ограничение", ограничение)
    если ограничение = 0 { вернуть }

    если ограничение > 0 & ограничение < длина(ст) {
        пусть байты = ст(:Байты) // TODO: оптимизация - избежать выделения памяти
        пусть № := 0
        пусть байтов := 0
        пусть число-байтов := 0

        пока ограничение > 0 {
            utf8.пропустить символ(байты, №, байтов)
            число-байтов := число-байтов + байтов
            ограничение--
        }
        
        пусть подстрока = извлечь(ст, 0, число-байтов) // TODO: оптимизация - избежать выделения памяти
        р.сб.добавить строку(подстрока)
    } иначе {
        р.сб.добавить строку(ст)
    }
}

фн (р: Разборщик) добавить символ(сим: Символ) {
    // TODO: обработать размещение
    р.сб.добавить символ(сим)
}


фн (р: Разборщик) добавить целое10(ц: Цел64) {
    р.добавить число10(ц(:осторожно Слово64), ц < 0)
}

фн (р: Разборщик) добавить число10(к: Слово64, нег: Лог) {

    если нег { к := -к }

    пусть б := Байты[выделить: 21] // 21 шт, достаточно для Max(Слово64) + знак
    пока истина {
         пусть ост := к % 10(:Слово64)
         к := к  / 10(:Слово64)
         б.добавить(( ост + '0'(:Слово64))(:Байт))

         если к = 0(:Слово64) { прервать }
    }

    // заполнение
    пусть ширина := р.размер
    если ширина > длина(б) {
        ширина := ширина - длина(б)
        если р.нули {
            ширина--
            пока ширина > 0 { б.добавить('0'(:Байт)); ширина-- }
            р.добавить знак(б, нег)
        } иначе { // пробелы
            р.добавить знак(б, нег)
            пока ширина > 0 { б.добавить(ПРОБЕЛ); ширина-- }
        }
    } иначе {
        р.добавить знак(б, нег)
    }

    р.добавить байты реверсом(б, длина(б))
    // TODO: обработать размещение
}

фн (р: Разборщик) добавить знак(б: Байты, нег: Лог) {
    если нег {
         б.добавить('-'(:Байт))
    } иначе если р.знак {
        б.добавить('+'(:Байт))
    }
}

// TODO: маска, сдвиги?
фн (р: Разборщик) добавить число16(к: Слово64) {

    пусть б := Байты[ выделить: 17] //17 шт, достаточно для Max(Слово64) 
    пусть сим: Байт := 0
    пока истина {
         пусть ост := к % 16(:Слово64)
         к := к  / 16(:Слово64)

         если ост < 0xA {
            сим := ( ост + '0'(:Слово64))(:Байт)
         } иначе {
            сим := ( ост - 0xA + 'A'(:Слово64))(:Байт)
         }
         б.добавить(сим)
         
         если к = 0(:Слово64) { прервать }
    }

    // заполнение
    пусть ширина := р.размер
    если ширина > длина(б) {
        ширина := ширина - длина(б)
        если р.нули {
            если р.альт { ширина := ширина - 2 }
            пока ширина > 0 { б.добавить('0'(:Байт)); ширина-- }
            р.добавить префикс числа(б, 'x')
        } иначе { // пробелы
            р.добавить префикс числа(б, 'x')
            пока ширина > 0 { б.добавить(ПРОБЕЛ); ширина-- }
        }
    } иначе {
        р.добавить префикс числа(б, 'x')
    }

    // TODO: обработать размещение
    р.добавить байты реверсом(б, длина(б))
}

// 0x для шестнадцатеричного ...
фн (р: Разборщик) добавить префикс числа(б: Байты, сим: Символ) {
    если р.альт {
        б.добавить(сим(:Байт))
        б.добавить('0'(:Байт))
    }
}

// все символы должны быть однобайтовые
фн (р: Разборщик) добавить байты реверсом(байты: Байты, №: Цел64) {
    р.сб.число-символов := р.сб.число-символов + №
    №--
    пока № >= 0 {
        //TODO: не оптимально, сделать slice или что-то еще, чтобы добавить все сразу
        р.сб.байты.добавить(байты[№])
        №--
    }
}

//==== вещественные

// TODO: размер, точность и остальные настройки
фн (р: Разборщик) добавить вещественное(в: Вещ64) {
    если р.вещ-экспонента {
        р.сб.добавить строку(sysapi_float64_to_string("%e", в))
    } иначе {
        р.сб.добавить строку(sysapi_float64_to_string("%g", в))
    }
}
